# 2. Everyday Types

## ğŸ”¹The primitives : string, number, boolean

- string : ë¬¸ìì—´
- number : ìˆ«ì
- boolean : true, false ê°’

```tsx
// ts - string
const str: string = 'hello';
// ts - number
const num: number = 10;
// ts - boolean
const done: boolean = true;

```

<aside>
ğŸ’¡ String, Number, Booleanì´ë¼ê³  ì‘ì„±í•  ìˆ˜ë„ ìˆìœ¼ë‚˜, ì´ëŸ¬í•œ ë¹ŒíŠ¸ì¸ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ëŠ” ë“œë¬¼ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ, í•­ìƒ string, number, booleanì„ ì“°ë„ë¡ í•˜ì

</aside>

## ğŸ”¹Array

- ë°°ì—´ ì›ì†Œì˜ íƒ€ì…ê³¼ arrayë¥¼ ë‚˜íƒ€ë‚´ëŠ” `[]`ë¥¼ ì‚¬ìš©í•˜ì—¬ íƒ€ì… ì •ì˜
- `string[ ]`ì€ `Array<string>`ìœ¼ë¡œë„ ì“¸ ìˆ˜ ìˆë‹¤.

```tsx
const strArr : string[] = ['a', 'b'];
const numArr : number[] = [1,2]
```

- ì£¼ì˜: [number]ê³¼ number[]ì€ ë‹¤ë¥´ë‹¤!
    - `number[]`: ë°°ì—´ì˜ ì›ì†Œì˜ íƒ€ì…ì€ ëª¨ë‘ number, ì›ì†Œì˜ ê°¯ìˆ˜ëŠ” ìƒê´€ì—†ë‹¤.
    - `[number]` : ì²« ë²ˆì§¸ ì›ì†Œì˜ íƒ€ì…ì€ numberì—¬ì•¼í•˜ë©°, ì›ì†Œì˜ ê°¯ìˆ˜ëŠ” í•˜ë‚˜ì—¬ì•¼ í•œë‹¤.
    
    ```tsx
    const numArr: number[] = [1,2,3]; // âœ… OK
    const numTuple: [number] = [1,2,3]; // âŒ ERROR
    /**
    Type '[number, number, number]' is not assignable to type '[number]'.
      Source has 3 element(s) but target allows only 1.
     */
    ```
    

## ğŸ”¹any

- anyëŠ” íƒ€ì…ì²´í¬ë¥¼ í•˜ê³  ì‹¶ì§€ ì•Šì„ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íƒ€ì…ì´ë‹¤.
- anyëŠ” íƒ€ì…ì²´í¬ë¥¼ í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—, ë¬¸ë²•ì ìœ¼ë¡œë§Œ ë§ë‹¤ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” ì–´ë– í•œ ì—ëŸ¬ë„ ë˜ì§€ì§€ ì•ŠëŠ”ë‹¤.

```tsx
const obj: object = {};
obj.func(); // âŒ ERROR : property func does not exist on type 'object'

const obj2: any = {};
obj2.func(); // âœ… NO ERROR

```

- ì•”ë¬µì  anyë¥¼ í—ˆìš©í•˜ê³  ì‹¶ì§€ ì•Šë‹¤ë©´? `noImplicitAny`
    - íƒ€ì… ì •ì˜ë¥¼ í•˜ì§€ ì•Šì•˜ëŠ”ë° íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ê·¸ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ì—†ì„ ê²½ìš°ì—”, ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì…ì„ `any` ë¼ê³  ë‘”ë‹¤. ì´ ê²½ìš°ì˜ anyë¥¼ `implicit any`ë¼ê³  í•œë‹¤.
    - anyëŠ” íƒ€ì… ì²´í¬ë¥¼ í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ë¶ˆí™•ì‹¤í•˜ë‹¤.
    - implicit anyë¥¼ í”¼í•˜ë ¤ë©´ `noImplicitAny` ì»´íŒŒì¼ëŸ¬ í”Œë˜ê·¸ë¥¼ ì„¤ì •í•´ì£¼ì–´ì„œ, implicit anyë¥¼ í—ˆìš©í•˜ì§€ ì•Šê²Œ í•´ì•¼ í•œë‹¤.

## ğŸ”¹Type Annotations on Variables

- const, let, varë¡œ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œ, ëª…ì‹œì ìœ¼ë¡œ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì§€ì •í•  ìˆ˜ ìˆë‹¤.
    
    ```tsx
    const me:string = 'yejin';
    ```
    
- ê·¸ëŸ¬ë‚˜, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” **íƒ€ì…ì„ ì¶”ë¡ **í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ëª…ì‹œì ìœ¼ë¡œ ì‘ì„±í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.
    
    ![https://i.imgur.com/b45cuJt.png](https://i.imgur.com/b45cuJt.png)
    

## ğŸ”¹Â Functions

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œëŠ” í•¨ìˆ˜ì˜ `íŒŒë¼ë¯¸í„°`ì™€ `ë¦¬í„´ê°’`ì˜ íƒ€ì…ì„ ì§€ì •í•  ìˆ˜ ìˆë‹¤.

### Parameter Type Annotations : íŒŒë¼ë¯¸í„° íƒ€ì… í‘œê¸°

- í•¨ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œ, ê° íŒŒë¼ë¯¸í„° ì˜†ì— í•¨ìˆ˜ê°€ ë°›ì•„ë“¤ì´ëŠ” íŒŒë¼ë¯¸í„°ì˜ íƒ€ì…ì€ ë¬´ì—‡ì¸ì§€ ì§€ì •í•œë‹¤.
    
    ```tsx
    function say(name: string, age: number){
        console.log(name.toUpperCase());
        console.log(age.toFixed(0))
    }
    
    ```
    
- íƒ€ì…ì„ ì§€ì •í•œ í•¨ìˆ˜ì— argumentë¥¼ ë„˜ê¸°ë©´, parameterì—ì„œ ì§€ì •í•œ íƒ€ì…ê³¼ ê°™ì€ì§€ í™•ì¸í•œë‹¤.
    
    ```tsx
    // Argument of type 'boolean' is not assignable to parameter of type 'string'.
    say(true, 'string')
    
    ```
    
- íƒ€ì…ì„ ì§€ì •í•˜ì§€ ì•Šë”ë¼ë„, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” í•¨ìˆ˜ì˜ **argumentì˜ ê°¯ìˆ˜ì— ë§ê²Œ í˜¸ì¶œí•˜ì˜€ëŠ”ì§€**ë¥¼ ì²´í¬í•œë‹¤.
    
    ```tsx
    const func = (a, b, c) => {
        return a + b + c;
    }
    
    func("a");
    // Expected 3 arguments, but got 1.
    ```
    
- íƒ€ì…ì´ undefinedì—¬ë„ ê°¯ìˆ˜ì— ë§ì¶°ì„œ ì¸ìë¥¼ ë„£ì–´ì•¼ í•œë‹¤.
    
    ```tsx
    const func = (age: number, name: undefined) => {
      return [age, name];
    }
    
    func(14) // âŒ Error
    // Expected 2 arguments, but got 1.
    // An argument for 'name' was not provided.
    
    func(14, undefined) // âœ… OK
    ```
    
    - unknownì¼ ë•Œë„ ë§ˆì°¬ê°€ì§€!
        
        ```tsx
        const func = (age: number, name: unknown) => {
          return [age, name];
        }
        
        func(14) // âŒ Error
        // Expected 2 arguments, but got 1.
        ```
        
- Optional íƒ€ì…ê³¼ undefined íƒ€ì…ì˜ ì°¨ì´
    - optional : ì¸ìë¥¼ ë„˜ê¸°ì§€ ì•Šì•„ë„ ë¨
    - undefined: ì¸ìë¥¼ ë„˜ê²¨ì•¼ í•¨.
    
    ```tsx
    interface Func {
      name?: string,
      age: undefined,
    }
    
    const func = ({name, age}: Func) => {
      return [name, age];
    }
    
    func({}); // âŒ ERROR!
    /**
     * Argument of type '{}' is not assignable to parameter of type 'Func'.
      Property 'age' is missing in type '{}' but required in type 'Func'.
     */
    
    func({age: undefined}); // âœ… OK
    ```
    

### Return Type Annotation : ë¦¬í„´ íƒ€ì… í‘œê¸°

- íŒŒë¼ë¯¸í„° ë¦¬ìŠ¤íŠ¸ ë‹¤ìŒì— ë¦¬í„´ê°’ì˜ íƒ€ì…ì„ ì§€ì •í•  ìˆ˜ ìˆë‹¤.
    
    ```tsx
    function getFavoriteNumber(): number {
      return 26;
    }
    ```
    
- ëŒ€ë¶€ë¶„ì˜ ê²½ìš° íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” `return` ë¬¸ì„ í†µí•´ í•¨ìˆ˜ì˜ ë¦¬í„´ê°’ì„ ì¶”ë¡ í•œë‹¤.
    
    ![https://i.imgur.com/uUdVzmy.png](https://i.imgur.com/uUdVzmy.png)
    

### Anonymous Functions : ìµëª… í•¨ìˆ˜

- **contextual typing** (ë§¥ë½ì  íƒ€ì…)
    
    íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” í•¨ìˆ˜ê°€ ì–´ë–»ê²Œ í˜¸ì¶œë˜ëŠ”ì§€ë¥¼ ì•Œê³  ìˆëŠ” ê³³ì— ìˆìœ¼ë©´, í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„°ëŠ” ìë™ìœ¼ë¡œ íƒ€ì…ì´ ì£¼ì–´ì§„ë‹¤.
    
- ì˜ˆë¥¼ ë“¤ì–´, ì•„ë˜ì™€ ê°™ì€ ê²½ìš°ëŠ” forEachë¬¸ì˜ ì½œë°± í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„°ì¸ sì˜ íƒ€ì…ì´ ì£¼ì–´ì§€ì§€ ì•Šì•˜ë‹¤. ê·¸ëŸ¬ë‚˜, names ë°°ì—´ì˜ íƒ€ì…ì„ ì¶”ë¡ í•˜ì—¬ íŒŒë¼ë¯¸í„° sì˜ íƒ€ì…ì„ ì¶”ë¡ í•˜ì˜€ë‹¤.
    
    ```tsx
    // No type annotations here, but TypeScript can spot the bug
    const names = ["Alice", "Bob", "Eve"];
    
    // Contextual typing for function
    names.forEach(function (s) {
      console.log(s.toUppercase()); // Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?
    });
    
    ```
    
    ì´ëŠ” Array interfaceê°€ `ì œë„¤ë¦­` ì´ê³ , ê·¸ ì½œë°± í•¨ìˆ˜ì˜ ì¸ìì— ëŒ€í•œ íƒ€ì…ì„ ì œë„¤ë¦­ íƒ€ì…ìœ¼ë¡œ ì •ì˜í•´ì£¼ê³  ìˆê¸° ë•Œë¬¸ì´ë‹¤.
    
    ```tsx
    interface Array<T> {
    	forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
    }
    ```
    

## ğŸ”¹Object Types

- objectì˜ íƒ€ì…ì„ ì§€ì •í•˜ê¸° ìœ„í•´ì„œëŠ” í”„ë¡œí¼í‹°ì˜ íƒ€ì…ì„ ë‚˜ì—´í•˜ë©´ ëœë‹¤.
- í”„ë¡œí¼í‹°ëŠ” `,`ë‚˜ `;`ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬ë¶„í•  ìˆ˜ ìˆë‹¤.
    
    ```tsx
    // The parameter's type annotation is an object type
    function printCoord(pt: { x: number, y: number }) {
      console.log("The coordinate's x value is " + pt.x);
      console.log("The coordinate's y value is " + pt.y);
    }
    printCoord({ x: 3, y: 7 });
    ```
    
- íƒ€ì…ì„ ë”°ë¡œ ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´, anyë¡œ ê°€ì •í•œë‹¤.
    
    ```tsx
    // The parameter's type annotation is an object type
    function printCoord(pt) {
      console.log("The coordinate's x value is " + pt.x);
      console.log("The coordinate's y value is " + pt.y);
    }
    ```
    
    - d.ts
        
        ```tsx
        declare function printCoord(pt: any): void;
        ```
        

### Optional Properties

- ì–´ë– í•œ íŒŒë¼ë¯¸í„°ëŠ” ì˜µì…”ë„ë¡œ ë‘ê³  ì‹¶ë‹¤ë©´, í”„ë¡œí¼í‹° ì´ë¦„ ë’¤ì— `?`ë¥¼ ë¶™ì¸ë‹¤.
    
    ```tsx
    function coordinate(point:{x:number, y:number, z?:number}){
     // ...
    }
    
    coordinate({x:1, y:2}); // OK
    coordinate({x:1, y:2, z:3}) // OK
    
    ```
    
- ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œëŠ” ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í”„ë¡œí¼í‹°ì— ì ‘ê·¼í•˜ë©´ `undefined`ë¥¼ ë°˜í™˜í•œë‹¤. ê·¸ëŸ¬ë¯€ë¡œ, optional propertyë¥¼ ì‚¬ìš©í•˜ê¸° ì „ì— `undefined`ì¸ì§€ë¥¼ ë¨¼ì € ì²´í¬í•´ì•¼ í•œë‹¤.
    - ifë¬¸ìœ¼ë¡œ í™•ì¸
    
    ```tsx
    function coordinate(point:{x:number, y:number, z?:number}){
      if(point.z !== undefined){
          return point.z.toFixed(0);
      }
    }
    ```
    
    - optional chainingìœ¼ë¡œ í™•ì¸
    
    ```tsx
    function coordinate(point:{x:number, y:number, z?:number}){
      // optioinal chaining ì‚¬ìš©
      return point.z?.toFixed(0);
    }
    ```
    

## ğŸ”¹Â Union Types

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ íƒ€ì… ì‹œìŠ¤í…œì—ì„œëŠ” ì—¬ëŸ¬ ì—°ì‚°ìë¥¼ í™œìš©í•´ì„œ ìƒˆë¡œìš´ íƒ€ì…ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ì—¬ê¸°ì„œëŠ” Unionì´ë¼ëŠ” íƒ€ì…ìœ¼ë¡œ, ê¸°ì¡´ íƒ€ì…ì„ í•©ì¹˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³¸ë‹¤. 

### Union Type ì •ì˜í•˜ê¸°

- ìœ ë‹ˆì–¸ íƒ€ì…ì€ **ë‘ ê°œ ì´ìƒì˜ íƒ€ì…ìœ¼ë¡œ êµ¬ì„±**ë˜ì–´ìˆë‹¤.
- ìœ ë‹ˆì–¸ íƒ€ì…ì€ ê°’ì˜ íƒ€ì…ì´ **ì´ íƒ€ì…ë“¤ ì¤‘ í•˜ë‚˜ë¼ëŠ” ì˜ë¯¸**ì´ë‹¤.
- ìœ ë‹ˆì–¸ íƒ€ì…ì˜ ê° íƒ€ì…ì„ Unionì˜ `members`ë¼ê³  í•œë‹¤.

```tsx
function student(id: number|string){
    return id;
}

student(10); // OK
student('1111'); // OK
student(true); // ERROR

```

### Working with Union Types

- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ëª¨ë“  ìœ ë‹ˆì–¸ ë©¤ë²„ì—ê²Œ ìœ íš¨í•œ ê²ƒë§Œ í•  ìˆ˜ ìˆê²Œ í•œë‹¤.
    
    ì˜ˆë¥¼ ë“¤ì–´ `string | number`ë¼ëŠ” ìœ ë‹ˆì–¸ íƒ€ì…ì¸ ê°’ì´ ìˆë‹¤ê³  ê°€ì •í•´ë³´ì.
    ì´ ê°’ì— `string`ì—ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë©”ì†Œë“œëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.
    
    ![https://i.imgur.com/XIzaNeX.png](https://i.imgur.com/XIzaNeX.png)
    
- ì´ì— ëŒ€í•œ í•´ê²°ì€ `Narrowing`ì´ë‹¤.
    
    Narrowingì„ í†µí•´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” íŠ¹ì •í•œ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆë‹¤.
    
    - typeofë¥¼ í†µí•œ Narrowing
    
    ```tsx
    function student(id: number|string){
        if(typeof id === 'string'){
            return id.toUpperCase();
        }else{
            return id.toFixed(0);
        }
    }
    
    ```
    
    - Array.isArrayë¥¼ í†µí•´ narrowing
    
    ```tsx
    function getNumbers(num: number[] | number){
        if(Array.isArray(num)){
            return num.join('');
        }
        return `${num}`;
    }
    ```
    

- ë§Œì•½ ëª¨ë“  ìœ ë‹ˆì–¸ ë©¤ë²„ê°€ ê³µí†µì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë©”ì„œë“œê°€ ìˆë‹¤ë©´, narrowingì„ í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.
    
    ```tsx
    function getFirstThree(x: number[] | string) {
      return x.slice(0, 3);
    }
    
    ```
    

## ğŸ”¹Type Aliases

- `type alias`ëŠ” íƒ€ì…ì— ì´ë¦„ì„ ë¶™ì´ê³ , ê·¸ ì´ë¦„ìœ¼ë¡œ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆê²Œ í•œë‹¤.
- type aliasë¥¼ ì‚¬ìš©í•˜ë©´ í¸ë¦¬í•˜ê²Œ ê°™ì€ íƒ€ì…ì„ ì—¬ëŸ¬ ë²ˆ ë¶€ì—¬í•  ìˆ˜ ìˆë‹¤.
- ì˜ˆì‹œ
    - objectì— typeì„ ë¶™ì„
        
        ```tsx
        type Point = {
          x: number;
          y: number;
        };
        
        // Exactly the same as the earlier example
        function printCoord(pt: Point) {
          console.log("The coordinate's x value is " + pt.x);
          console.log("The coordinate's y value is " + pt.y);
        }
        
        printCoord({ x: 100, y: 100 });
        
        ```
        
    - unionì— íƒ€ì… ë¶™ì„
        
        ```tsx
        type ID = string | number;
        
        ```
        
- aliasëŠ” aliasì¼ ë¿!
    
    Aliasë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒê³¼, Aliasë˜ì§€ ì•Šì€ ê²ƒì€ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ë¡œì¨ëŠ” ê°™ì€ íƒ€ì…ì´ê¸° ë•Œë¬¸ì´ë‹¤.
    
    myNameì„ UserNameì´ë¼ëŠ” íƒ€ì…ìœ¼ë¡œ ì„ ì–¸í•˜ì˜€ì§€ë§Œ, â€˜lillieâ€™ë¼ëŠ” stringìœ¼ë¡œ ì¬í• ë‹¹ì´ ê°€ëŠ¥í•˜ë‹¤. íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ë‘˜ ë‹¤ stringìœ¼ë¡œ ë³´ê¸° ë•Œë¬¸ì´ë‹¤.
    
    ```tsx
    type UserName = string;
    
    let myName: UserName = 'yejin';
    
    myName = 'lillie';
    ```
    

## ğŸ”¹Interface

- interfaceëŠ” object typeì„ ì„ ì–¸í•˜ëŠ” ë˜ ë‹¤ë¥¸ ë°©ì‹ì´ë‹¤.

```tsx
interface Point {
  x: number;
  y: number;
}
 
function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}
 
printCoord({ x: 100, y: 100 });
```

- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” `êµ¬ì¡°ì ìœ¼ë¡œ íƒ€ì´í•‘ëœ íƒ€ì… ì‹œìŠ¤í…œ` ì´ë‹¤.  íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ì˜¤ì§, printCoordë¡œ ì „ë‹¬ë˜ëŠ” ê°’ì˜ `êµ¬ì¡°`ì—ë§Œ ê´€ì‹¬ì´ ìˆë‹¤.
    
    > it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript aÂ *structurally typed*Â type system.****
    > 
    
    [https://www.typescriptlang.org/docs/handbook/type-compatibility.html#starting-out](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#starting-out)
    
    > The basic rule for TypeScriptâ€™s structural type system is thatÂ `x`
    Â is compatible withÂ `y` ifÂ `y` has at least the same members asÂ `x`
    > 
    
    ```tsx
    interface A {
      a: number;
      b: number;
      c: number;
    }
    
    interface B {
      a: number;
      b: number;
    }
    
    const a: A = {a:10, b:20, c:30}
    
    const b: B = a;
    ```
    

## ğŸ”¹Type Aliasì™€ Interfaceì˜ ì°¨ì´ì 

### Interface

- ìƒˆë¡œìš´ í”„ë¡œí¼í‹°ë¥¼ ì¶”ê°€í•˜ê¸° ìœ„í•´, ê°™ì€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì¬ì„ ì–¸í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ë‹¤. (re-openì´ ê°€ëŠ¥í•˜ë‹¤.)
    
    ```tsx
    interface UserInfo {
      name: string;
    }
    
    interface UserInfo {
      getName: () => string;
    }
    
    const userInfo: UserInfo = {
      name: 'yejin',
      getName(){
        return this.name;
      }
    }
    ```
    
- ìƒˆë¡œìš´ íƒ€ì…ì„ ì¶”ê°€í•˜ëŠ” ë°©ì‹ : `extends`
    
    ```tsx
    interface Name {
      name: string;
    }
    
    interface MyInfo extends Name {
      age: number;
    }
    
    const myInfo : MyInfo = {
      name: 'yejin',
      age: 0,
    }
    ```
    
- interfaceëŠ” ê°ì²´ì˜ ëª¨ì–‘ì„ ì„ ì–¸í•˜ê¸° ìœ„í•´ì„œë§Œ ì“°ì¸ë‹¤. primitive íƒ€ì…ì„ renameí•  ìˆ˜ ì—†ë‹¤.
    
    ```tsx
    interface EvenNumber = number; // âŒ
    interface OddNumber { // âœ…
        value: number;
    }
    ```
    
- ì—ëŸ¬ ë©”ì‹œì§€ì— ì¸í„°í˜ì´ìŠ¤ì˜ ì´ë¦„ì´ ë³´ì¸ë‹¤. ë‹¨, í˜•íƒœê°€ ê°™ë”ë¼ë„ ì¸í„°í˜ì´ìŠ¤ ì´ë¦„ì„ ì ì§€ ì•Šìœ¼ë©´, ì—ëŸ¬ ë©”ì‹œì§€ì—ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ì´ë¦„ì´ ë³´ì´ì§€ ì•ŠëŠ”ë‹¤.
    
    ```tsx
    interface Mammal {
        name: string
    }
    
    function echoMammal(m: Mammal) {
        console.log(m.name)
    }
    
    echoMammal({  name: 12343 })
    
    // âŒ Error : The expected type comes from property 'name' which is declared here on type 'Mammal'
    
    function echoAnimal(m: { name: string }) {
        console.log(m.name)
    }
    
    echoAnimal({ name: 12345 })
    
    // âŒ Error : The expected type comes from property 'name' which is declared here on type '{ name: string; }'
    ```
    
- í‚¤ ì¶©ëŒì‹œ
    
    íƒ€ì…ì´ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´, ì—ëŸ¬ê°€ ë‚œë‹¤. ë‹¨, íƒ€ì…ì´ ì¼ì¹˜í•˜ë©´ ì—ëŸ¬ê°€ ì•„ë‹ˆë‹¤.
    
    ```tsx
    interface First {
        a: string;
    }
    
    interface Second extends First { 
        a: number;
    }
    /**
     * Interface 'Second' incorrectly extends interface 'First'.
      Types of property 'a' are incompatible.
        Type 'number' is not assignable to type 'string'.
     */
    ```
    

### Type

- ìƒˆë¡œìš´ í”„ë¡œí¼í‹°ë¥¼ ì¶”ê°€í•˜ê¸° ìœ„í•´, ê°™ì€ íƒ€ì…ì„ ì¬ì„ ì–¸í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤. (re-openì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.)
    
    ```tsx
    type UserInfo = {
      name: string;
    }
    
    type UserInfo = {
      getName: () => string;
    }
    
    // Error : Duplicate identifier 'UserInfo'
    ```
    
- ìƒˆë¡œìš´ íƒ€ì…ì„ ì¶”ê°€í•˜ëŠ” ë°©ì‹ : `intersections`
    
    ```tsx
    type Name = {
      name: string;
    }
    
    type MyInfo = Name & {
      age: number;
    }
    
    const myInfo : MyInfo = {
      name: 'yejin',
      age: 0,
    }
    ```
    
- typeì€ primitiveë¥¼ renameí•  ìˆ˜ ìˆìœ¼ë©°, ê°ì²´ì˜ í˜•íƒœë¥¼ ì„ ì–¸í•˜ê¸° ìœ„í•´ ì“°ì¼ ìˆ˜ ìˆë‹¤.
    
    ```tsx
    type EvenNumber = number
    type AllNumber = {
        value: number;
    }
    ```
    
- í‚¤ ì¶©ëŒì‹œ
    
    ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤. ë‹¨, ì¶©ëŒëœ í‚¤ëŠ” `never` íƒ€ì…ì´ ëœë‹¤.
    
    ```tsx
    type B = {
        b: string;
    }
    
    type C = {
        b: number;
    }
    
    type D = B & C;
    
    const ex: D = {b: 234}; // âŒ Type 'number' is not assignable to type 'never'.
    
    ```
    

## ğŸ”¹Type Assertions

- type assertionì€ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì•Œì§€ ëª»í•˜ëŠ” íƒ€ì…ì— ëŒ€í•´ ì•Œë ¤ì£¼ëŠ” ê²ƒì´ë‹¤. `as` ë‚˜ `angle-bracket` ì„ ì‚¬ìš©í•˜ì—¬ íƒ€ì… ë‹¨ì–¸ì„ í•  ìˆ˜ ìˆë‹¤.
    
    ```tsx
    const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
    const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");
    Try
    ```
    
    ```tsx
    interface IdolGroup {
      name: string | number;
    }
    
    const exo: IdolGroup = {
      name: 'EXO'
    }
    
    function sayName(name: string){
      return name;
    }
    
    /** âŒ
     * Argument of type 'string | number' is not assignable to parameter of type 'string'.
      Type 'number' is not assignable to type 'string'
     */
    sayName(exo.name);
    
    sayName(exo.name as string); // âœ…
    sayName(<string>exo.name); // âœ…
    ```
    

- type asssertionì€ ì»´íŒŒì¼ëŸ¬ê°€ **ì»´íŒŒì¼ íƒ€ì„ì— ì œê±°**ëœë‹¤. ë”°ë¼ì„œ ëŸ°íƒ€ì„ì—ëŠ” ì–´ë– í•œ ì²´í‚¹ë„ ì—†ë‹¤.
    
    ì•„ë˜ ì˜ˆì‹œëŠ” ìœ„ ì½”ë“œë¥¼ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì»´íŒŒì¼ëŸ¬ë¡œ ëŒë¦° í›„ì˜ outputì´ë‹¤. interfaceì™€ type assertion ëª¨ë‘ ì œê±°ëœ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. 
    
    ```tsx
    const exo = {
        name: 'EXO'
    };
    function sayName(name) {
        return name;
    }
    /** âŒ
     * Argument of type 'string | number' is not assignable to parameter of type 'string'.
      Type 'number' is not assignable to type 'string'
     */
    sayName(exo.name);
    sayName(exo.name); // âœ…
    ```
    
- type assertionì€ ì¢€ ë” êµ¬ì²´ì ì´ê±°ë‚˜ ëœ êµ¬ì²´ì ì¸ ë°©ì‹ìœ¼ë¡œì˜ ë³€í™˜ë§Œ í—ˆìš©ëœë‹¤.
    - ì˜ˆ - ëœ êµ¬ì²´ì ì¸ anyë‚˜ unknownìœ¼ë¡œ íƒ€ì… ë‹¨ì–¸
        
        ```tsx
        const age = 123 as any;
        const school = 'HGU' as unknown;
        ```
        
    - ë‘ íƒ€ì… ê°„ì˜ ì¶©ëŒë˜ëŠ” ê²ƒì€ í—ˆìš©ë˜ì§€ ì•ŠëŠ”ë‹¤.
        
        ```tsx
        const address = 'Korea' as number;
        /** âŒ
         * Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. 
         * If this was intentional, convert the expression to 'unknown' first
         */
        ```
        
    
- ë§Œì•½ ì¶©ëŒë˜ëŠ” ìƒí™©ì—ì„œë„ ì •ë§ assertionì´ ë§ë‹¤ë©´, ë¨¼ì € anyë‚˜ unknownìœ¼ë¡œ assertionì„ í•˜ê³ ë‚˜ì„œ íƒ€ì… ë‹¨ì–¸ì„ í•´ì•¼ í•œë‹¤.
    
    ```tsx
    const age = 123 as any as string;
    const school = 'HGU' as unknown as object;
    ```
    

## ğŸ”¹Literal Types

- `string`ê³¼ `number`ì— ìˆì–´ì„œëŠ” íŠ¹ì • ë¬¸ìì—´ê³¼ ìˆ«ìë¥¼ ì¶”ë¡ í•  ìˆ˜ ìˆë‹¤.
    
    JSì—ì„œ varë‚˜ letìœ¼ë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ëŠ” ê·¸ ê°’ì„ ë°”ê¿€ ìˆ˜ ìˆìœ¼ë‚˜, constë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ëŠ” ê°’ì„ ë³€ê²½í•  ìˆ˜ ì—†ë‹¤.
    
    ì´ë¥¼ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œë„ ë°˜ì˜í•˜ì—¬, letìœ¼ë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ëŠ” stringí˜¹ì€ numberë¡œ íƒ€ì…ì´ ì¶”ë¡ ì´ ëœë‹¤. ê·¸ëŸ¬ë‚˜ constë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ëŠ” ê·¸ íŠ¹ì •í•œ ë¬¸ìì—´ê³¼ ìˆ«ìê°€ ë³´ì—¬ì§„ë‹¤. ì´ë¥¼ `literal types` ë¼ê³  í•œë‹¤.
    
    ```tsx
    let changingNumber = 123; // number 
    const constantNumnber = 123; // 123
    
    let changingString = "Hello World"; // string
    const constantString = "Hello World"; // "Hello World"
    ```
    
- literalì„ Unionìœ¼ë¡œ ë¬¶ì–´ì„œ ì“°ë©´ ì¢‹ë‹¤.
    
    ```tsx
    function printText(s: string, alignment: "left" | "right" | "center") {
      // ...
    }
    ```
    
    ```tsx
    function compare(a: string, b: string): -1 | 0 | 1 {
      return a === b ? 0 : a > b ? 1 : -1;
    }
    ```
    

### Literal Inference

ê°ì²´ì˜ í•„ë“œê°’ì€ ë³€ê²½ë  ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ê°ì²´ì˜ í•„ë“œëŠ” íŠ¹ì •í•œ ê°’ì´ ì•„ë‹Œ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ í•˜ê²Œ ëœë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ì•„ë˜ì˜ req.methodëŠ” â€œGETâ€ì´ ì•„ë‹Œ `string`ìœ¼ë¡œ ì¶”ë¡ ëœë‹¤. handleRequestê°€ â€œGETâ€ë§Œì„ ë°›ëŠ”ë‹¤ë©´, req.methodëŠ” string íƒ€ì…ì´ë¯€ë¡œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œëŠ” ì—ëŸ¬ê°€ ëœë‹¤.

```tsx
const handleRequest = (url: string, method: "GET" | "POST") => {
    return [url, method];
}

const req = { url: "https://example.com", method: "GET" };
handleRequest(req.url, req.method);
// âŒ Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.
```

ì´ë¥¼ í•´ì†Œí•˜ëŠ” ë°©ì•ˆì€ 2ê°€ì§€ì´ë‹¤.

1. `Type Assertion`ì„ ë‘ ê³³ì— ëª¨ë‘ ì¶”ê°€í•œë‹¤.
    - change 1ì€ req.methodëŠ” í•­ìƒ â€˜GETâ€™ì´ë¼ëŠ” ë¦¬í„°ëŸ´ íƒ€ì…ì„ì„ ëª…ì‹œí•˜ëŠ” ê²ƒì´ë‹¤. ì¶”í›„ì— req.methodë¥¼ â€˜GETâ€™ì´ ì•„ë‹Œ ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ë³€ê²½í•˜ëŠ” ê²ƒì„ ë§‰ì•„ì¤€ë‹¤.
    - chagne 2ëŠ” req.methodê°€ GETì„ì„ ì•Œê³  ìˆë‹¤ëŠ” í‘œì‹œì´ë‹¤.
    
    ```tsx
    // Change 1:
    const req = { url: "https://example.com", method: "GET" as "GET" };
    
    // Change 2
    handleRequest(req.url, req.method as "GET");
    ```
    
2. `as const` ë¥¼ ë¶™ì—¬ì„œ, ê°ì²´ë¥¼ `type literal` ë¡œ ë³€ê²½í•œë‹¤.
    
    `as const` ë¥¼ ë¶™ì´ë©´, ëª¨ë“  í”„ë¡œí¼í‹°ê°€ `literal type`ì„ì„ ë§í•´ì£¼ê²Œ ëœë‹¤.
    
    ![./images/Sheep-Screenshot 2022-05-25 PM 6.45.03.png](2%20Everyday%20Types%207dba01d84672426192ce0cfc6d39d50c/Sheep-Screenshot_2022-05-25_PM_6.45.03.png)
    

- `Object.freeze`ì™€ `as const`ì˜ ì°¨ì´ì 
    
    `as const` ë¥¼ ë¶™ì¸ ê°ì²´ëŠ” type literalë¡œ ë³€ê²½ë˜ì–´ handleRequestì— ë„˜ê¸¸ ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë‚˜ Object.freezeë¡œ ë¬¶ì€ req2ëŠ” ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
    
    ```tsx
    const req = { url: "https://example.com", method: "GET"} as const;
    handleRequest(req.url, req.method); // âœ…
    
    const req2 = Object.freeze({ url: "https://example.com", method: "GET"});
    handleRequest(req2.url, req2.method); // âŒ Argument of type 'string' is not assignable to parameter of type '"GET"'
    ```
    
    ì´ëŠ” DTSë¥¼ ë³´ë©´ ê·¸ ì°¨ì´ë¥¼ ì•Œ ìˆ˜ ìˆë‹¤. 
    
    `as const`ë¥¼ ë¶™ì¸ ê°ì²´ëŠ” í•„ë“œì— `readonly` ê°€ ìˆê³ , ê·¸ ë‚´ë¶€ëŠ” Literal typeì´ ë˜ì—ˆë‹¤. ë°˜ë©´, Object.freezeë¡œ ë¬¶ì€ ê°ì²´ëŠ” `Readonly` íƒ€ì…ìœ¼ë¡œ ë¬¶ì˜€ìœ¼ë‚˜, ê·¸ ë‚´ë¶€ëŠ” stringì´ë‹¤. ë”°ë¼ì„œ, handleRequestì— ì „ë‹¬ë  ìˆ˜ ì—†ë‹¤. 
    
    ```tsx
    declare const req: {
        readonly url: "https://example.com";
        readonly method: "GET";
    };
    declare const req2: Readonly<{
        url: string;
        method: string;
    }>;
    ```
    

## ğŸ”¹`null` and `undefined`

JSì—ì„œ ë‘ ê°œì˜ primitive ê°’ì´ ìˆë‹¤. ì´ ê°’ì„ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì–´ë–»ê²Œ ì²˜ë¦¬í• ì§€ëŠ” `strictNullChecks` ì˜µì…˜ì— ë”°ë¼ ë‹¤ë¥´ë‹¤.

- `strictNullChecks` off
    
    nullê³¼ undefinedì¼ ìˆ˜ë„ ìˆëŠ” ê°’ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. nullì´ë‚˜ undefinedì¸ì§€ë¥¼ ì²´í¬í•´ì£¼ì§€ ì•ŠëŠ” ê²ƒì€ ë²„ê·¸ì´ë¯€ë¡œ, strictNullChecks ì˜µì…˜ì€ ì¼œë‘ëŠ” ê²ƒì„ ì¶”ì²œí•œë‹¤.
    
    ```tsx
    function doSomething(x: string | null) {
        console.log("Hello, " + x.toUpperCase());
    }
    ```
    
- `strictNullChecks` on
    
    ê°’ì´ nullì´ë‚˜ undefinedì¼ ìˆ˜ë„ ìˆëŠ” ê°’ì´ë©´, narrowingì„ í†µí•´ ê°’ì´ nullì´ë‚˜ undefinedì¸ì§€ë¥¼ í•­ìƒ ì²´í¬í•´ì•¼ í•œë‹¤. 
    
    ```tsx
    function doSomething(x: string | null) {
      if (x === null) {
        // do nothing
      } else {
        console.log("Hello, " + x.toUpperCase());
      }
    }
    ```
    

### **Non-null Assertion Operator (Postfix `!`)**

postfixë¡œ `!` ê°€ ìˆìœ¼ë©´, ì´ ê°’ì´ nullì´ë‚˜ undefinedê°€ ì•„ë‹ˆë¼ëŠ” type assertionì´ ëœë‹¤. ì•„ë˜ ì˜ˆì‹œëŠ” `strictNullChecks` ê°€ ì¼œì ¸ìˆì–´ë„, nullì´ ì•„ë‹ˆë¼ëŠ” íƒ€ì… ë‹¨ì–¸ìœ¼ë¡œ ì¸í•˜ì—¬ ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ” ê²ƒì„ ë³´ì—¬ì¤€ë‹¤.

```jsx
function doSomething(x: string | null) {
    console.log("Hello, " + x!.toUpperCase()); // âœ…
}
```

## ğŸ”¹Â Enums

Enumì€ ë‹¤ë¥¸ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ ë‹¤ë¥¸ ê¸°ëŠ¥ë“¤ê³¼ëŠ” ë‹¤ë¥´ê²Œ, ìë°”ìŠ¤í¬ë¦½íŠ¸ ì–¸ì–´ì— ì¶”ê°€ë˜ì–´ ëŸ°íƒ€ì„ì— ì˜í–¥ì„ ì£¼ê²Œ ëœë‹¤. 

- TS
    
    ```tsx
    enum Role {
        "MASTER" = "MASTER",
        "MEMBER" = "MEMBER"
    }
    const mesage: string = 'sdf';
    ```
    
- JSë¡œ ë³€í™˜
    
    ```jsx
    "use strict";
    var Role;
    (function (Role) {
        Role["MASTER"] = "MASTER";
        Role["MEMBER"] = "MEMBER";
    })(Role || (Role = {}));
    const mesage = 'sdf'; // íƒ€ì…ì´ ì‚¬ë¼ì§
    ```
    

ì°¸ê³ ë¡œ ì•„ë˜ ê¸€ì„ ì‚´í´ë³´ì.

[TypeScript enumì„ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²Œ ì¢‹ì€ ì´ìœ ë¥¼ Tree-shaking ê´€ì ì—ì„œ ì†Œê°œí•©ë‹ˆë‹¤. - LINE ENGINEERING](https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/)

## ğŸ”¹Â Less Common Primitives

- `bigint`
    
    ```jsx
    // Creating a bigint via the BigInt function
    const oneHundred: bigint = BigInt(100);
     
    // Creating a BigInt via the literal syntax
    const anotherHundred: bigint = 100n;
    ```
    
- `symbol`
    
    ```jsx
    const firstName = Symbol("name");
    const secondName = Symbol("name");
    ```
    
    - dts
    
    ```tsx
    declare const firstName: unique symbol;
    declare const secondName: unique symbol;
    ```
